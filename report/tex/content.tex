% !TeX spellcheck = fr
% !TeX encoding = UTF-8

% -- Exercice 1
\section{Partie 1 : Modélisation du problème}

Dans cette partie, nous nous intéressons à la modélisation du problème du \textit{Monde des Blocs} en tant que problème de planification.

\subsection{Définition et déclaration des variables}
Voici une liste des variables utilisées, avec leur domaine et leur signification :

\begin{itemize}
    \item $n$ : le nombre de blocs
    \item $k$ : le nombre de piles
    \item $E$ : un état donné du Monde des Blocs
    \item $actions(E)$ : l'ensemble de toutes les actions possibles pour l'état $E$
    \item $t(E, i \rightarrow j)$ : le nouvel état obtenu en appliquant l'action $i \rightarrow j$ à l'état $E$
    \item $G = (S, A)$ : le graphe d'états, où $S$ est l'ensemble des états possibles et $A$ est l'ensemble des transitions entre les états
\end{itemize}

\subsection{Question 1}

\textit{Combien d'actions différentes sont-elles possibles pour l'état $E_1$ ?}

Supposons que l'état $E_1$ dispose de $k = 3$ piles non-vides. Chaque pile peut envoyer un bloc vers $k - 1$ autres piles. Donc, pour chaque pile, il y a $k - 1$ actions possibles. Par conséquent, le nombre total d'actions possibles pour l'état $E_1$ est $(k - 1) \times k = 6$ actions.

\subsection{Question 2}

\textit{Étant donné un état $E$ de $n$ blocs sur $k$ piles, quelle est la taille maximale de $actions(E)$ ?}

Pour maximiser le nombre d'actions possibles, chaque pile doit contenir au moins un bloc, permettant ainsi des déplacements de blocs entre toutes les piles. Ainsi, chaque pile peut envoyer un bloc à $k - 1$ autres piles. Le nombre total d'actions possibles est donc $k(k - 1)$.

\subsection{Question 3}

\textit{Étant donné un état $E$ de $n$ blocs sur $k$ piles ayant $v$ piles vides, quelle est la taille de $actions(E)$ ?}

Avec $v$ piles vides, il reste $k - v$ piles contenant des blocs. Chaque pile active peut envoyer un bloc à $k - 1$ autres piles, donc le nombre total d'actions est $(k-v)(k-1)$.

\subsection{Question 4}\label{q:4}

\textit{Quel est l'ordre de grandeur du nombre total d'états différents possibles ?}

Le nombre total d'états est exponentiel par rapport au nombre de blocs et linéaire par rapport au nombre de piles. 

Pour s'en convaincre, on peut considérer que pour atteindre l'état final, chaque bloc doit être déplacé au moins une fois. Considérons cette situation qui est donc une borne minimale du chemin optimal parmi le graphe d'états possibles. Dans ce cas, à chaque niveau de profondeur, on a vu avec la question 2 qu'il y a $k(k - 1)$ actions possibles au maximum. Ainsi, chaque état à chaque niveau possède $k(k - 1)$ états fils. On peut donc en déduire que le nombre total d'états est de l'ordre de $O(k(k - 1)^n) = O((k^2 - k)^n) = O(k^2n)$.

On se retrouve alors avec une borne minimale du nombre maximum d'états possible en $O(k^2n)$, ce qui est exponentiel par rapport au nombre de blocs et linéaire par rapport au nombre de piles.

\section{Partie 2 : Définition du graphe d'états}

\subsection{Question 5}

\textit{Le graphe d'états $G$ est-il orienté ?}

Oui, le graphe d'états $G$ est orienté. Chaque action menant d'un état $E$ à un état $E'$ représente un arc orienté dans le graphe.

\subsection{Question 6}

\textit{Quels sont les algorithmes qui peuvent être utilisés pour rechercher ce plus court chemin ?}

Plusieurs algorithmes peuvent être utilisés pour rechercher le plus court chemin, tels que Bellman-Ford, BFS, DFS et Dijkstra, en fonction des spécificités du graphe (poids, orientation, etc.).

\subsection{Question 7}

\textit{Quel est l'algorithme le plus efficace pour rechercher ce plus court chemin ?}

Dans le contexte d'un graphe non pondéré comme celui du Monde des Blocs, BFS (Breadth-First Search) est généralement le plus efficace, car il trouve le plus court chemin en explorant uniformément autour du nœud source.

DFS est un autre algorithme de parcours de graphe qui se concentre sur l'exploration en profondeur d'une branche du graphe avant de revenir en arrière pour explorer d'autres branches. Il peut également être utilisé pour trouver le plus court chemin. 

Chacun de ces algorithmes a ses avantages et inconvénients. Mais surtout, ils peuvent être améliorés en utilisant des heuristiques pour guider la recherche vers des solutions plus optimales.

\subsection{Question 8}

\textit{Quelle est la complexité en temps de cet algorithme par rapport à $|S|$ et $|A|$ ?}

La complexité temporelle de BFS est linéaire, soit O(|S| + |A|), où |S| est le nombre de sommets (états) et |A| est le nombre d'arêtes (actions) dans le graphe.

\subsection{Question 9}

\textit{Quelle est la complexité en temps de cet algorithme par rapport au nombre de blocs (n) et de piles (k) ?}

La complexité temporelle de l'algorithme par rapport au nombre de blocs (n) et de piles (k) est exponentielle, car le nombre total d'états possibles croît exponentiellement avec l'augmentation de n et k (voir question 4, section \ref{q:4}).

\section{Partie 3 : Heuristiques pour le monde des blocs}

\subsection{Question 10}

On commence par exécuter le programme de recherche de plus court chemin pour 4 piles et un nombre de blocs variant de 6 à 8. On obtient les résultats suivants :

\begin{minipage}{\dimexpr\linewidth-20pt}
    \begin{lstlisting}[language=bash, caption={Résultats de l'exécution du programme de recherche de plus court chemin}, label={lst:plus_court_chemin_results_no_heuristics}]
        $ make run
        Enter the number of stacks: 4
        Enter the number of blocs: 6
        Optimal solution of length 7 found in 12982 iterations and 0.060902 seconds
        [...]
        $ make run
        Enter the number of stacks: 4
        Enter the number of blocs: 7
        Optimal solution of length 9 found in 188569 iterations and 1.04769 seconds
        [...]
        $ make run
        Enter the number of stacks: 4
        Enter the number of blocs: 8
        Optimal solution of length 11 found in 2224481 iterations and 15.6446 seconds
        [...]
    \end{lstlisting}
\end{minipage}

Les résultats montrent une augmentation exponentielle du nombre d'itérations et du temps d'exécution avec l'augmentation du nombre de blocs. Pour améliorer les performances de l'algorithme, on peut adopter des heuristiques adéquates. Trois heuristiques sont introduites :

\begin{itemize}
    \item $h_1$ : Nombre de blocs ne se trouvant pas sur la dernière pile.
    \item $h_2$ : Nombre de blocs ne se trouvant pas sur la dernière pile, plus deux fois le nombre de blocs $b$ tels que $b$ se trouve sur la dernière pile mais devra nécessairement être enlevé de cette pile pour ajouter et/ou supprimer d'autres blocs sous lui.
    \item $h_3$ : Nombre de blocs de $E_i$ ne se trouvant pas sur la dernière pile, plus le nombre de blocs se trouvant au-dessus de chaque bloc ne se trouvant pas sur la dernière pile.
\end{itemize}

Pour qu'une heuristique soit admissible, elle doit toujours sous-estimer le coût réel pour atteindre l'objectif. Formellement, une heuristique $h$ est admissible si pour tout état $E$, $h(E) \leq \delta (E, E')$ où $\delta (E, E')$ est la distance réelle entre $E$ et l'état cible $E'$.

Une heuristique $h$ est dite plus informée qu'une heuristique $h'$ si, pour tout état $E$, $h(E) \geq h'(E)$, tandis que les deux heuristiques sont incomparables s'il existe deux états $E$ et $E'$ tels que $h(E) < h'(E)$ et $h(E') > h'(E')$.

\subsection{Question 11}

\textit{L'heuristique $h_1$ est-elle admissible ?}

L'heuristique $h_1$ est admissible, car le nombre de blocs ne se trouvant pas sur la dernière pile représente une limite inférieure du nombre de mouvements nécessaires pour atteindre l'état final. En effet, chaque bloc doit au moins une fois être déplacé vers la dernière pile, sous-estimant ainsi le coût réel pour atteindre l'objectif.

\subsection{Question 12}

\textit{L'heuristique $h_2$ est-elle admissible ?}

L'heuristique $h_2$ est également admissible. Elle prend en compte le coût de déplacement des blocs qui sont sur la dernière pile, mais doivent être déplacés pour permettre à d'autres blocs de se placer en dessous. En multipliant ce nombre par deux, on reste dans une estimation inférieure du coût réel. En effet, pour chaque bloc sur la dernière pile, mais n'étant pas à la bonne hauteur, il faudra au minimum 2 déplacements de ce bloc considéré pour l'enlever puis le remettre sur la dernière pile. Il s'agit d'une estimation minimum, car chaque bloc ainsi déplacé peut nécessiter plus de 2 mouvements pour atteindre sa position finale.

\subsection{Question 13}

\textit{L'heuristique $h_2$ est-elle plus informée, moins informée, ou incomparable par rapport à l'heuristique $h_1$ ?}

L'heuristique $h_2$ est plus informée que l'heuristique $h_1$. En plus de compter les blocs ne se trouvant pas sur la dernière pile, elle prend en compte le coût supplémentaire pour déplacer les blocs déjà sur la dernière pile, mais qui doivent être temporairement déplacés. Ainsi, $h_2$ donnera une valeur de coût égale ou supérieur à celle fournie par $h_1$, et donne donc une meilleure estimation du coût réel. Elle est donc plus informée.

\subsection{Question 14}

\textit{L'heuristique $h_3$ est-elle admissible ?}

L'heuristique $h_3$ est admissible. Elle compte non seulement les blocs qui ne sont pas sur la dernière pile, mais aussi le nombre de blocs qui doivent être déplacés pour permettre le placement d'autres blocs. Cette mesure fournit une sous-estimation du coût réel, car elle ne prend pas en compte les déplacements multiples ni l'ordre optimal de déplacement des blocs.

\subsection{Question 15}

\textit{L'heuristique $h_3$ est-elle plus informée, moins informée, ou incomparable par rapport à l'heuristique $h_2$ ?}

Tandis que $h_2$ compte de manière spécifique les déplacements nécessaires pour les blocs sur la dernière pile, $h_3$ se concentre sur une vue plus globale de tous les blocs qui ne sont pas à leur place. En fonction de la situation, par exemple si la dernière pile est déjà bien remplie, $h_2$ peut donner une meilleure estimation du coût réel que $h_3$ puisqu'il reste peu de blocs sur les autres piles. C'est bien sûr l'inverse quand la dernière pile est vide. Ainsi, les deux heuristiques sont incomparables.

On peut ainsi trouver des contres-exemples :

\[
    \exists E_1, E_2 \in E \ | \ h_2(E_1) < h_2(E_2) \land h_3(E_1) > h_3(E_2).
\]

\begin{figure}
    \centering

    \begin{tabular}{ccc} 
        \scalebox{0.6}{
        \begin{tikzpicture}
            \tikzstyle{every node}=[font=\LARGE]
            \draw (4,24.75) rectangle node {\LARGE a} (5.75,23);
            \draw (4,22.75) rectangle node {\LARGE d} (5.75,21);
            \draw (7,22.75) rectangle node {\LARGE c} (8.75,21);
            \draw (10,22.75) rectangle node {\LARGE e} (11.75,21);
            \draw (10,24.75) rectangle node {\LARGE b} (11.75,23);
            \draw [](4,20.75) to (5.75,20.75);
            \draw [](7,20.75) to (8.75,20.75);
            \draw [](10,20.75) to (11.75,20.75);
            \node [font=\LARGE] at (5,20) {0};
            \node [font=\LARGE] at (8,20) {1};
            \node [font=\LARGE] at (11,20) {2};
            \node [font=\LARGE] at (8,19) {$E_1$};
        \end{tikzpicture}
        }
        
        & \hspace{2cm} &

        \scalebox{0.6}{
        \begin{tikzpicture}
            \tikzstyle{every node}=[font=\LARGE]
            \draw (4,24.75) rectangle node {\LARGE a} (5.75,23);
            \draw (4,22.75) rectangle node {\LARGE d} (5.75,21);
            \draw (7,22.75) rectangle node {\LARGE c} (8.75,21);
            \draw (10,22.75) rectangle node {\LARGE e} (11.75,21);
            \draw (7,24.75) rectangle node {\LARGE b} (8.75,23);
            \draw [](4,20.75) to (5.75,20.75);
            \draw [](7,20.75) to (8.75,20.75);
            \draw [](10,20.75) to (11.75,20.75);
            \node [font=\LARGE] at (5,20) {0};
            \node [font=\LARGE] at (8,20) {1};
            \node [font=\LARGE] at (11,20) {2};
            \node [font=\LARGE] at (8,19) {$E_2$};
        \end{tikzpicture}
        }
    \end{tabular}
    
    \caption{Exemples de deux états $E_1$ et $E_2$, pour $k = 3$ et $n = 5$.}.
    \label{fig:contre_exemple_h2_h3}
\end{figure}

Dans l'illustration suivante \ref{fig:contre_exemple_h2_h3}, on peut voir :

\[
    h(E_1) = 
    \begin{cases} 
        h_1(E_1) = 3 \\
        h_2(E_1) = 5 \\
        h_3(E_1) = 4
    \end{cases}
    \quad
    h(E_2) =
    \begin{cases} 
        h_1(E_2) = 4 \\
        h_2(E_2) = 4 \\
        h_3(E_2) = 6
    \end{cases}
\]

On a donc $h_2(E_1) > h_3(E_2) \land h_2(E_1) < h_3(E_2)$, ce qui montre que les deux heuristiques sont incomparables.